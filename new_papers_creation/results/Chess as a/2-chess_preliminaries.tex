
\section{Chess Preliminaries}
\label{sec:chess}


We represent moves using Universal Chess Interface (UCI) notation, which combines the starting square and the destination square to represent a move.\footnote{For more details see \url{https://en.wikipedia.org/wiki/Universal_Chess_Interface}} 
The move in Figure~\ref{fig:move_notation} is represented as \texttt{f1b5} in UCI where \texttt{f1} indicates the starting square and \texttt{b5} denotes the ending square.
While the SAN notation is the standard choice for gameplay, we prefer UCI %
(see Appendix~\ref{sec:san} for why we pick UCI over SAN). 

For training language models, we first tokenize games represented in UCI notation using a simple regular expression based tokenizer, which considers a board square symbol such as \texttt{b1} as a single token.
This gives us a vocabulary of 77 token types, 
which includes the 64 squares, piece type symbols, and other special symbols (see Table~\ref{tab:model_vocab}).\footnote{In initial experiments we used a delimiter token to indicate move boundary. However, removing it did not degrade performance and made training faster due to reduced sequence length.}
For example, the move sequence ``\pos{e2e4 e7e5 g1f3}" is tokenized to ``\pos{e2}, \pos{e4}, \pos{e7}, \pos{e5}, \pos{g1}, \pos{f3}". We then train an autoregressive language model on these move sequences, using the standard maximum likelihood objective.

\input{figures/chess_vocab}

\input{figures/rap}