\begin{figure*}\centering
\newcommand{\anonvar}{\rule{0.7em}{0.4pt}}
\newcommand{\rbox}[2]{\parbox{#1}{
\raggedright
\hangindent=1.5em
\hangafter=1
#2}}
\newlength{\pushdown}
\setlength{\pushdown}{0.5cm}

\resizebox{0.9\textwidth}{!}{%
%
\begin{tikzpicture}
[level distance=1.1cm,
    level 1/.style={sibling distance=7cm},
    level 2/.style={sibling distance=5cm},
    level 3/.style={sibling distance=4cm},
proofstep/.style={rectangle,draw=black,inner sep=4pt}]
\node [proofstep, label=left:{$t=0$}, fill=lavendergray] (get) {get(Person, ToPlace, on$\_$time)}
child { node [proofstep,left=-2cm, label=left:{$t=1$}] (arrive) {arrive(Person, \anonvar, \anonvar, ToPlace, ArriveAt)}
    child { node [proofstep, fill=celadon, label=left:{$t=2$}] (ready) {ready(Person, LeaveAt, PrepTime)}
        child { node [proofstep, fill=celadon, label=left:{$t=3$}, left=0.2cm] (alarm) {alarm(Perosn, Time)} child{node [proofstep, label=left:{$t=4$}] (ground_alarm) {alarm(i,8)} } }
        child { node [proofstep,below left=\pushdown and -2.2cm, fill=celadon, label=left:{$t=5$}] (leaveat) {LeaveAt = Time + PrepTime.}}
    }
    child { node [proofstep,below right=2.5cm and -2.5cm, label=left:{$t=6$}] (commute) {\rbox{5cm}{commute(Person, FromPlace, ToPlace, With, CommuteTime)}}
        child { node [proofstep,below=-0.3cm, label=left:{$t=7$}] (commutex) {commute(i, home, work, car, 1)} }
    }
    child { node [proofstep,below right=2.8cm and 0.5cm, label=left:{$t=8$}] (traffic) {\rbox{5cm}{traffic(LeaveAt, ToPlace, With, TrTime)}} 
        child { node [proofstep,below left=1\pushdown and -1cm, label=left:{$t=9$}] (weather) {weather(snow, Precipitation)} }
        child { node [proofstep,below right=1\pushdown and -0.6cm, fill=atomictangerine, label=left:{$t=10$}] (precipitation) {Precipitation $>=$ 2} }
        child { node [proofstep,below right=1\pushdown and 1cm, label=left:{$t=11$}] (travelTime) {TrTime = 1} }
    }
    child { node [proofstep,below right=2.5\pushdown and 0, label=left:{$t=12$}] (arriveat) {\rbox{5cm}{ArriveAt = LeaveAt + CommuteTime + TrTime}} }
}
child { node [proofstep, label=left:{$t=13$}] (cal) {calendarEntry(Person, ToPlace, ArriveAt)}
    child { node [proofstep, fill=atomictangerine, label=left:{$t=14$}] (calx) {calendarEntry(i, work, 9)} }
};
\end{tikzpicture} 
}
%Amos: can this figure appear a little bit earlier (closer to where it is called in text)?
    \caption{Sample proof tree for the \emph{because}-clause of the statement: ``If it snows tonight then wake me up early because I want to get to work on time''. Proof traversal is depth-first from left to right ($t$ gives the order). Each node in the tree indicates a rule's head, and its children indicate the rule's body. For example, the nodes highlighted in green indicate the rule \prologTerm{ready(Person,LeaveAt,PrepTime) $\coloneq$ alarm(Person, Time) $\wedge$ LeaveAt = Time+PrepTime}. The \textGoal we want to prove, $\goal$=\prologTerm{get(Person, ToPlace, on$\_$time)}, is in the tree's root. If a proof is successful, the variables in $\goal$ get grounded (here \prologTerm{Person} and \prologTerm{ToPlace} are grounded to \prologTerm{i} and \prologTerm{work}, respectively). The highlighted orange nodes are the uncovered commonsense presumptions.}
    \label{fig:prooftree}
    \vspace{-1em}
\end{figure*}
%\facomment{add a figure for the proof tree}
% Proof is performed using backward chaining, a backtracking algorithm implemented recursively. In each step of the recursion, the input is a goal to prove and the output is the proof's success/failure. in order to prove a query, a rule or fact whose head unifies with the query is retrieved from \KB. The proof continues recursively for each predicate in the body and succeeds if all the statements in the body of a rule are \prologTerm{true}. The base case (leaf) is when a fact is retrieved from \KB.
% \tmcomment{remove the left-to-right if it is not }