% \begin{figure*}\centering
% \newcommand{\anonvar}{\rule{0.7em}{0.4pt}}
% \newcommand{\rbox}[2]{\parbox{#1}{
% \raggedright
% \hangindent=1.5em
% \hangafter=1
% #2}}
% % \newlength{\pushdown}
% \setlength{\pushdown}{0.5cm}

% \resizebox{\textwidth}{!}{%
% %
% \begin{tikzpicture}
% [level distance=1.1cm,
%     level 1/.style={sibling distance=8cm},
%     level 2/.style={sibling distance=6cm},
%     level 3/.style={sibling distance=4cm},
% proofstep/.style={rectangle,draw=black,inner sep=4pt},
% emph/.style={edge from parent/.style={dashed,black,thick,draw}},
% norm/.style={edge from parent/.style={solid,black,thick,draw}}]
% \node (get) {\textcolor{ao(english)}{I want to get to work on time}}
% child[emph] {node (get_2) {then \textcolor{internationalorange}{I will get to work on time}}
% child[norm] {node (commute) {if \textcolor{ao(english)}{my commute time to work increases}}
%     child[emph] { node (commute_increase) {then \textcolor{internationalorange}{my commute time to work increases}}
%         child[norm] { node[left=0.5cm] (traffic) {if \textcolor{ao(english)}{there is traffic}} child[emph]{node (traffic_2) {then \textcolor{internationalorange}{there will be traffic}} 
%             child[norm]{node[left=0.5cm] (snow_2inch) {if \textcolor{ao(english)}{it snows more than 2 inches}}}
%         } }
%     }
% }
% child[norm] { node (leave) {and \textcolor{ao(english)}{I leave the house earlier}}
%     child[emph] { node (leave_early) {then \textcolor{internationalorange}{I will leave the house earlier}}
%         child[norm]{node[right=0.5cm] (wake_up) {if \textcolor{ao(english)}{I wake up earlier}}}
%     }
%   }
% };
% \end{tikzpicture} 
% }
%     \caption{Sample simplified proof tree for the statement: ``If it snows tonight then wake me up early because I want to get to work on time''. The proof tree is a collection of if-then rules from the knowledge base. The solid black lines connect each rule's head to its body and the black dashed lines indicate the unification operation. Orange nodes indicate the head of the rule and the green nodes are statements in the body. The number of children of each orange node indicates the number of statements in the body of that rule. The proof is carried out recursively through a depth-first-search from left to right. In each step (a green node), a rule whose head (orange node) matches the current node is retrieved from the knowledge base and the next step of the proof attempts to recursively prove each statement in its body. The root is the proved input query. leaf nodes are facts in the knowledge base}
%     \label{fig:prooftree_simple}
% \end{figure*}

\begin{figure*}\centering
\newcommand{\anonvar}{\rule{0.7em}{0.4pt}}
\newcommand{\rbox}[2]{\parbox{#1}{
\raggedright
\hangindent=1.5em
\hangafter=1
#2}}
% \newlength{\pushdown}
\setlength{\pushdown}{0.5cm}

\resizebox{0.7\textwidth}{!}{%
%
\begin{tikzpicture}
[level distance=1.1cm,
    level 1/.style={sibling distance=8cm},
    level 2/.style={sibling distance=6cm},
    level 3/.style={sibling distance=4cm},
proofstep/.style={rectangle,solid,thick,draw=black,inner sep=4pt},
emph/.style={edge from parent/.style={dashed,black,thick,draw}},
norm/.style={edge from parent/.style={solid,black,thick,draw}}]
\node [proofstep] (get) {\textcolor{ao(english)}{status(i, dry, tuesday)}}
child[emph] {node [proofstep] (get_2) {\textcolor{internationalorange}{status(Person1=i, dry, Date1=tuesday)}}
child[norm] {node [proofstep] (commute) { \textcolor{ao(english)}{isInside(Person1=i, Building1, Date1=tuesday)}}
    child[emph] { node [proofstep] (commute_increase) { \textcolor{internationalorange}{isInside(i, home, tuesday)}}
    }
}
child[norm] { node [proofstep] (leave) {\textcolor{ao(english)}{building(Building1)}}
    child[emph] { node [proofstep] (leave_early) { \textcolor{internationalorange}{building(home)}}
    }
  }
};
\end{tikzpicture} 
}
    \caption{Sample simplified proof tree for query \prologTerm{status(i, dry, tuesday)}. dashed edges show successful unification, orange nodes show the head of the rule or fact that is retrieved by the unification operator in each step and green nodes show the query in each proof step. This proof tree is obtained using the Prolog program or \KB~shown in Tab.~\ref{tab:kb_examples}. In the first step, unification goes through all the rules and facts in the table and retrieves rule number 2 whose head unifies with the query. This is because the query and the rule head's functor name is \prologTerm{status} and they both have 3 arguments. Moreover, the arguments all match since \prologTerm{Person1} grounds to atom \prologTerm{i}, grounded atom \prologTerm{dry} matches in both and variable \prologTerm{Date1} grounds to \prologTerm{tuesday}. In the next step, the proof iterates through the predicates in the rule's body, which are \prologTerm{isInside(i, Building1, tuesday)} and \prologTerm{building(Building1)}, to recursively prove them one by one using the same strategy. Each of the predicates in the body become the new query to prove and proof succeeds if all the predicates in the body are proved. Note that once the variables are grounded in the head of the rule they are also grounded in the rule's body.}
    \label{fig:prooftree_simple}
\end{figure*}