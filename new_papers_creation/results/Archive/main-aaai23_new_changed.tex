\documentclass[letterpaper]{article} % DO NOT CHANGE THIS
\usepackage{aaai23}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet}  % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\usepackage{natbib}  % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\usepackage{caption} % DO NOT CHANGE THIS AND DO NOT ADD ANY OPTIONS TO IT
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in}  % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in}  % DO NOT CHANGE THIS
%
% These are recommended to typeset algorithms but not required. See the subsubsection on algorithms. Remove them if you don't have algorithms in your paper.
\usepackage{algorithm}
\usepackage{algorithmic}

%
% These are are recommended to typeset listings but not required. See the subsubsection on listing. Remove this block if you don't have listings in your paper.
\usepackage{newfloat}
\usepackage{listings}
\makeatletter
\def\lst@numbersymbol{}
\lst@Key{numbersymbol}{}{\def\lst@numbersymbol{#1}}
\lst@Key{numbers}{none}{%
    \let\lst@PlaceNumber\@empty
    \lstKV@SwitchCases{#1}%
    {none:\\%
     left:\def\lst@PlaceNumber{\llap{\normalfont
                \lst@numberstyle{\thelstnumber\lst@numbersymbol}\kern\lst@numbersep}}\\%
     right:\def\lst@PlaceNumber{\rlap{\normalfont
                \kern\linewidth \kern\lst@numbersep
                \lst@numberstyle{\lst@numbersymbol\thelstnumber}}}%
    }{\PackageError{Listings}{Numbers #1 unknown}\@ehc}}
\makeatother

\DeclareCaptionStyle{ruled}{labelfont=normalfont,labelsep=colon,strut=off} % DO NOT CHANGE THIS
\lstset{%
	basicstyle={\footnotesize\ttfamily},frame=tb,% footnotesize acceptable for monospace
	numbers=left,numberstyle=\footnotesize,xleftmargin=2em,% show line numbers, remove this entire line if you don't want the numbers.
	aboveskip=0pt,belowskip=0pt,%
	showstringspaces=false,tabsize=2,breaklines=true}

\lstset{
language=C++,
basicstyle=\small\ttfamily,
numbersep=5pt,
xleftmargin=20pt,
frame=tb,
framexleftmargin=20pt
}

\floatstyle{ruled}
\newfloat{listing}{tb}{lst}{}
\floatname{listing}{Listing}
%
% Keep the \pdfinfo as shown here. There's no need
% for you to add the /Title and /Author tags.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{url}
\usepackage{subcaption}
\usepackage{todonotes}
\usepackage{multirow}
\usepackage{xcolor}

\usepackage{anyfontsize}
\usepackage{dcolumn,caption,booktabs}
\usepackage{lipsum}

\usepackage{tabu}
\usepackage{array}
\usepackage{arydshln}

\newcommand{\var}[1]{{\operatorname{\mathit{#1}}}}

\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
%\newtheorem{definition}{Definition}


\newcommand\note[1]{\textcolor{red}{#1}}
\newcommand\commentout[1]{}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\newcommand{\ronen}[1]{\textbf{\color{blue}[RONEN:#1]}}



%
% These are are recommended to typeset listings but not required. See the subsubsection on listing. Remove this block if you don't have listings in your paper.
\usepackage{newfloat}
\usepackage{listings}
\DeclareCaptionStyle{ruled}{labelfont=normalfont,labelsep=colon,strut=off} % DO NOT CHANGE THIS
\lstset{%
	basicstyle={\footnotesize\ttfamily},% footnotesize acceptable for monospace
	numbers=left,numberstyle=\footnotesize,xleftmargin=2em,% show line numbers, remove this entire line if you don't want the numbers.
	aboveskip=0pt,belowskip=0pt,%
	showstringspaces=false,tabsize=2,breaklines=true}
\floatstyle{ruled}
\newfloat{listing}{tb}{lst}{}
\floatname{listing}{Listing}
%
% Keep the \pdfinfo as shown here. There's no need
% for you to add the /Title and /Author tags.


\newcommand\gNote[1]{\todo[inline, author=Guy, color=pink]{#1}}
%%\ccsPaper{9999} % TODO: replace with your paper number once obtained



 %for nice json code
\usepackage{listings}
\usepackage{xcolor}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    %backgroundcolor=\color{background},
    literate=
     %*{0}{{{\color{numb}0}}}{1}
      %{1}{{{\color{numb}1}}}{1}
      %{2}{{{\color{numb}2}}}{1}
      %{3}{{{\color{numb}3}}}{1}
      %{4}{{{\color{numb}4}}}{1}
      %{5}{{{\color{numb}5}}}{1}
      %{6}{{{\color{numb}6}}}{1}
      %{7}{{{\color{numb}7}}}{1}
      %{8}{{{\color{numb}8}}}{1}
      %{9}{{{\color{numb}9}}}{1}
      %{:}{{{\color{punct}{:}}}}{1}
      %{<}{{{\color{punct}{<}}}}{1}
      %{>}{{{\color{punct}{>}}}}{1}
      %{=}{{{\color{punct}{=}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}
\lstset{
language=json,
  basicstyle=\fontsize{2}{2}\selectfont\ttfamily,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
    xleftmargin=20pt,
frame=tb,
framexleftmargin=20pt
}
 % end for nice json code

%\setlength{\belowcaptionskip}{-10pt}


\title{Probabilistic Programs as an Action Description Language}

\author{Ronen I. Brafman, David Tolpin and Or Wertheim}
\affiliations{Department of Com\
     Ben Gurion University of the Negev\\
     \{brafman,tolpin,orwert\}@post.bgu.ac.il
    }

\usepackage{bibentry}

\begin{document}



\maketitle

\begin{abstract}
Actions description languages (ADLs), such as STRIPS, PDDL, and RDDL specify the input format for planning algorithms. Unfortunately, their syntax is foreign to most potential users of planning technology. Moreover, this syntax  limits the ability to describe complex and large domains. We argue that programming languages (PLs), and more specifically, probabilistic programming languages (PPLs), provide a more suitable alternative. PLs are familiar to all programmers, support complex data types and rich libraries for their manipulation, and have powerful constructs, such as loops, sub-routines, and local variables with which complex, realistic models and complex objectives can be simply and naturally specified. PPLs, specifically, make it easy to specify distributions, which are essential for stochastic models. The natural objection to this proposal is that PLs are opaque and too expressive, making reasoning about them difficult. However, PPLs also come with efficient inference algorithms, which, coupled with a growing body of work on sampling-based and gradient-based planning, imply that planning and execution monitoring can be carried out efficiently in practice. We expand on this proposal, illustrating its potential with  examples.
\end{abstract}

\section{Introduction}
Action description languages (ADLs), such as STRIPS~\cite{STRIPS}, PDDL~\cite{PDDL} and  RDDL~\cite{RDDL} specify the input format to planning algorithms. Unfortunately, their syntax is familiar to planning experts only, and not to potential users of planning technology. This has been recognized as a detriment to wider adoption of planning technology, and has led to much interest in the topic of knowledge acquisition for planning with an annual workshop.

The syntax of PDDL or RDDL can be mastered with some practice, but it comes with inherent expressive limitations.
These make the task of modeling large and complex real-world planning problems particularly challenging.
In this paper we argue for the use of
programming languages (PLs), and more specifically, probabilistic programming languages (PPLs)~\cite{GMR+08,MSP14,WVM14,GS15}, as more suitable alternatives to classical ADLs.

First, programmers know quite well how to use PLs to describe what they conceive in their minds. Second, it is  easier to write complex models in PLs because
they support complex data types and come with rich and efficient libraries for their manipulation. Describing arrays, linked-lists, vectors, trees, tensors etc.~is very difficult and cumbersome within a classic ADL. Such a description would not be transparent to anyone who reads it, is likely to be lengthy, and algorithms that use it would have no knowledge of its special properties. PLs also come with powerful constructs, such as loops, sub-routines, and local variables
that farther enhance our ability to naturally specify complex, realistic models and complex objectives.
More specifically, PPLs make it easy to specify distributions essential for modeling uncertainty about action effects and about the world's state --- essential components of many, if not most, real-world models. Moreover, most ADLs are restricted to closed models, whereas open models are easy to specify using PPLs.

Two related objections arise at this point: First, isn't this essentially telling us to use simulators? Second, we know from KR that expressive models are difficult to reason with, and more specifically,
in the case of full-fledged PLs, many inference tasks would be undecideable. Moreover, PLs are likely not structured enough to support good algorithms.

Indeed, simulation will play
a major role in planning algorithms based on PPL models. Simulation based methods such as algorithms for bandit problems~\cite{UCB},
MDPs~\cite{Puterman} and POMDPs~\cite{SV10,Despot}, RL algorithms~\cite{RLBook}, and Novelty-based methods~\cite{Novelty} have been very successful, recently.
And by using code to describe the model, we make it very easy to automatically generate efficient simulators~\cite{AOS-WS22} that can also
utilize various libraries for manipulating complex data types.

But PPL-based ADLs offer more than fast simulation.
We believe that future work can
exploit the growing body of supported inference algorithms  in service of planning and (no less important) execution monitoring. Specifically, PPLs make it easy to assess the
likelihood of new observations, allowing us to detect rare and unlikely events. They support more involved inference algorithms that can allow us to validate our plans and verify various properties.
PPLs also support annotation methods that are then used by the inference algorithms to make the computation more efficient.
One can use such annotations to construct more structured abstractions of the model that can guide computation (e.g., bias the sampling process towards better actions,
provide heuristic estimates), or to automatically detect components with special structure (e.g., deterministic variables) and exploit them.

Perhaps more importantly, PPLs can exploit automatic differentiation methods~\cite{auto-diff}. This implies that
recent efficient gradient-based planning methods, such as~\cite{pmlr-v130-bhandari21a} could be used to solve them.
%Older model-based gradient methods for POMDPs, exist as well
%(e.g., \cite{Aberdeen1}, and with sufficient interest, newer ones could be developed.


We believe the above makes the case for exploiting PPLs-based ADL in planning clear. The rest of this paper provides some background, expands on some of the above issues, and describes a number of examples that illustrate the points made above. We end with a suggested research agenda.

\section{Background}
\subsection{Action Description Languages}
%Action description languages have been developed within the  knowledge representation community and the planning community.
%While there are mutual influences, our focus is on the latter because they are the ones that most influence planning algorithms and serve as input to modern planners.

The basic components of most planning ADLs can be traced to the STRIPS language~\cite{STRIPS}. Propositions are used to describe the state of the world. These propositions are obtained by instantiating typed variables within a given
set of predicates, by objects. For example {\em On(BlockA,BlockB)} instantiates the binary predicate {\em On}
using two block objects, which yields a proposition that is either {\em true} or {\em false}.
Actions are usually specified as schema, e.g., {\em Pickup(?x)}, with its variables as place holders for appropriate objects. The action description specifies an applicability condition in the form of the precondition list --- a list of predicates with objects or variables that appear in the action schema, and a similar list describing its effects.

Planning languages have evolved to gradually more
complex descriptions, including quantification over
variables, conditional effects, resources, cost, preferences, constraints, axioms, non-Boolean finite-domain variables and much more~\cite{PDDL2.1,PDDL3,SAS+}. However, the constrained structure of the languages, their reliance on simple data types and lack of iterators makes it difficult to express complex models.

Moreover, none of the above languages support probabilistic models --- an essential component of  realistic models. These models require numeric information and, often, variables with continuous domains.
While an extension of PDDL to
probabilistic domains (PPDDL)~\cite{YouLit04} exists, it is mainly useful for transforming existing classical domains to probabilistic ones.

There are two notable exceptions. RDDL~\cite{RDDL} is a language developed for describing
dynamic Bayesian networks (DBNs)~\cite{DBN} that capture
the transition and observation functions of MDPs and
POMDPs. RDDL can be viewed as restricted, special purpose
probabilistic programming language. DBNs describe the conditional probability of post-action or observation values given the pre-action variables’ values.
Additional layers in between the pre-action and post-action layer allow intermediate computations. RDDL specs are declarative and explicitly specify the conditional probabilities of each variable value.
These values can be described using a broad set of supported
mathematical and logical functions and expressions.
A variable in one layer can be conditioned on the
previous layer, only. This can be viewed as a generative model that describes how each layer's values are generated from the previous layer.
Writing RDDL specifications requires mastering their syntax, and complex distributions may be difficult to specify. Intermediate computations are accomplished by adding intermediate DBN layers, which may be tedious since each variable can only be assigned once. As we show
later, a piece of code with local variables (possibly
assigned multiple times) and advanced control structures like loops can be much easier to specify, is more compact and is easier to understand. It also enables much more efficient sampling by simply using the code itself, whereas
RDDL specification must be parsed and sampled by a generic piece of code. And finaly, RDDL can describe graphical models, only. Hence, it cannot capture open-world domains.

BLOG~\cite{BLOG} was an important step in the direction we are espousing worth highlighting. Its syntax is  PL-like, and it supports set objects using which it is able to model open universes. However, it is short of a full-fledged PPL as it does not support rich data structure and itreserators, and lacks the inference capabilities of modern PPLs.


\subsection{Probabilistic Programming}
Probabilistic programming \cite{GMR+08,MSP14,WVM14,GS15}
  represents statistical models as programs written in an
  otherwise general programming language that provides syntax
  for the definition and conditioning of random variables.
  This means that programmers familiar with languages
  such as C++, Python, and more, can use them with almost no
  additional effort.
  Inference can be performed on probabilistic programs to
  obtain the posterior distribution or point estimates of the
  variables. Inference algorithms are provided by the
  PPL framework, and each algorithm is
  usually applicable to a wide class of probabilistic programs
  in a black-box manner. Probabilistic programs may contain loops, conditional
  statements, recursion, and operate on built-in and user
  defined data structures. The algorithms include
  Metropolis-Hastings\cite{MSP14,YHG14}, Hamiltonian
  Monte Carlo~\cite{Stan17}, expectation
  propagation~\cite{MWG+10}, extensions of Sequential Monte
  Carlo~\cite{WVM14,MYM+15,PWD+14,RNL+2016,MS18}, variational
  inference~\cite{WW13,KTR+17}, gradient-based
  optimization~\cite{Stan17,BCJ+19}, and others.

% \section{Related Work}
% RDDL. Reward Machines. KR action languages.


\section{Expressive Power}
We compare PPL-based specification with RDDL ones on two examples, seeking to illustrate that that PPL-based specification are easier to write and understand and can describe models that RDDL (and most other ADLs) cannot describe, and this is done without a need to learn a new language.
We focus on RDDL because it is the richest available ADL actively used in planning that supports probabilistic models. %as well as numerous constructs, such as simple
%iterators, arithmetic functions, etc.

\subsection{{\em Locusts Swarm} --- Multi-Stage Exogenous Events}
In this domain, aside from the agent's action, there are exogenous events that take place in parallel. To capture these exogenous events, RDDL needs to introduce intermediate layers in the DBN. If the event is complex, i.e., develops in multiple stages, then one layer is needed for each stage since every variable in a DBN can be assigned once only. With code, on the other hand, one can considerably simplify the domain description by using intermediate variables that describe the process and are reassigned multiple times.


In the {\em Locusts Swarm} domain, a swarm of locusts has invaded a nature reserve. The reserve is divided into nine primary cells that host a variety of endangered plants (10 tons of plants in each cell). The swarm moves from cell to cell twice during the night, eating half the plants of each cell it encounters.
It rests in the last cell visited at night during the following day.
The swarm moves stochastically depending on how many plants it smells in neighboring cells.
The reserve management has a crop duster that can spray pesticides at a single cell at night. These materials fade away after one day and need a whole day to disable the swarm. The only chance to stop this catastrophe is to spray, in advance, the cell in which the swarm will rest the following day.

RDDL requires a description that grows linearly because
increasing the number of nightly swarm transitions increases the number of required RDDL layers. Using a PPL, we can provide a fixed-size description. The verified RDDL code appears in Listing~\ref{lst:LocustsDomain_RDDL} and the pseudo PPL code in Listing~\ref{lst:LocustsDomain_PPL}.

\subsection{The Open World {\em Room Cleaning} Domain}
Using code, it is easy to describe open-world domains, i.e., domains in which the set of objects is not constant. This is very natural in many cases, and was demonstrated in BLOG~\cite{BLOG}. Below is a simple example of a domain describing a robot cleaning a children's room.
Such a domain does not correspond to a graphical model, because the size of the graph changes. Hence, it cannot be described in RDDL, PDDL, and
similar languages.

In the {\em Room Cleaning} domain, a robot cleans the children's room and should put all the toys in their place.
Each toy has a size and a level of difficulty to grasp, and a price.
The robot is initially aware of only three toys, some already in place.
It can place one toy per minute, yet it may drop and break a toy.
Every minute it receives positive reward for ordered toys based on their size, and a negative reward for unordered toys. If it breaks a toy, it receives a one-time penalty for its price. Every minute the robot is cleaning, it may find up to two new toys needing attention. The mission only ends when all toys are in place, and there is no maximum number of toys (See pseudo code in Listing~\ref{lst:openWorld_PPL}).

\subsection{Reward Machines and Factorization}
Recently, specification of complex, non-Markovian reward functions (i.e., ones depending on the entire past), captured by automata, and known as {\em reward machines} have become popular~\cite{RewardMachines}.
By taking the Cartesian product of
the underlying MDP and the reward-machine automaton, we
obtain a new, product MDP w.r.t~which the reward is Markovian.

Technically, reward machines allow us to decompose the "true" product MDP into smaller components. This is good for learning, representation, and planning. This is particularly important when MDPs are represented using
explicit tables. Probabilistic programs generalize this idea.
First, factored structure can be reflected directly in the code --- both the probabilistic part and the reward part.
Second, one can describe much more elaborate reward functions using code. In fact, utilities behave much like log-probabilities~\cite{wgr+:11,mpt+:16}, and the same machinery can be applied to them.




\section{Inference, Planning and Verification}
One advantage of PPLs is the (growing) body of inference algorithms they support. Sampling algorithms are obtained immediately, as the PPL code can be executed to yield simulated values. This is an important advantage over existing ADLs in which the description must be parsed and compiled to
an executable format.
%Special domain structure, which will be automatically reflected by the code.
Below we describe a number of additional inference tasks that can
be carried out using existing infra-structure.

\subsection{Computing Policy Parameters --- Sailing Domain}
In many applications, we seek to find optimal parameters for a policy
with fixed structure. A classic example is a fixed-size finite-state
controller, where we seek to find the structure of the best controller
for a POMDP with bounded size~\cite{meuleau1999learning,Poupart3}. The
Sailing Domain provides an example of such a problem~\cite{pg:04,ts:12}.

A sailing boat must travel
between the opposite corners A and B of a square lake of a
given size. At each step, the boat can head in 8
directions to adjacent squares. It always moves one unit-distance, called a {\em leg}. The
unit distance cost of movement depends on the wind, which can
also blow in 8 directions.
The cost of sailing into the wind is prohibitively high, upwind
is the highest feasible, and away from the wind is the lowest.
When the angle between the boat and the wind changes sign, the
sail must be tacked, which incurs an additional cost.
The wind is assumed to follow a random walk, either
staying the same or switching to an adjacent
direction, with a known probability.

For any given lake size, there is a non-parametric stochastic policy
that tabulates the distribution of legs for each
combination of location, tack, and wind.
However, such policy does not
generalize well --- if the lake surface area increases, due to a
particularly rainy year, for example, the policy is not
applicable to the new parts of the lake. Instead, we
can define a generalizable parametric policy balancing between
hesitation in anticipation for a better wind and rushing to the
goal at any cost.  The policy chooses a leg with log-probability
equal, up to a constant, to the sum of the leg cost and of the Euclidean
distance between the position after the leg and the goal,
multiplied by the policy parameter $\theta$ (the leg directed
into the wind is excluded
from choices). The greater the $\theta$, the higher is the
probability that a leg bringing the boat closer to the goal will
be chosen:
\begin{equation}
    \log \Pr(\var{leg}) = \var{leg-cost} + \theta \cdot\var{distance}(\var{next-location}, \var{goal}) + C
	\label{eqn:sailing-policy}
\end{equation}
In a probabilistic programming language,
\eqref{eqn:sailing-policy} can be expressed as
just \textit{sampling} from a categorical distribution:
\begin{equation}
    \var{leg} \sim \mathrm{Categorical}(\{\var{leg}_i: \Pr(\var{leg}_i)\})
\end{equation}
Inferring the policy, either offline or online, can be
accomplished using out-of-the-box inference algorithms for
models expressed by probabilistic programs. Note, that this
policy is differentiable with respect to $\theta$. This allows
to leverage automatic differentiation capabilities of modern
probabilistic programming languages for efficient optimization.

\subsection{Verification}
Probabilistic model-checking (a.k.a.~statistical model checking
in the verification community)~\cite{SMC} refers to the problem of
verifying certain properties of probabilistic transition systems.
Special purpose systems for this task such as PRISM~\cite{PRISM}
and UPPAAL-SMC~\cite{UPPAAL-SMC} have been developed. %
%\footnote{These systems consider models that explicitly model time.
%We believe this can be captured by PPLs, too, but we focus on
%standard stochastic models used in planning.}
The basic query in such systems is {\em what is the probability
of a future event satisfying some property}.
There are several settings in which the query is posed: (a) for
the fixed policy --- to check the robustness of a chosen policy,
(b) for a broad class (a distribution) of policies --- to check
the robustness of the agent in an average case, and
(c) for the worst-case policy with respect to the query --- to
check robustness of the agent in an adversarial setting. For
the above mentioned sailing domain, for example, we may query
about the probability of visiting the complementary corners of
the square lake, where bulrush grows, or about the probability
of travel cost execeeding a certain threshold.

This is a standard query in probabilistic programming. From the
probabilistic inference point of view, these three settings
involve analysis of the predictive posterior of the model and
differ only in the way the model is conditioned. For (a), the
predictive posterior is obtained for the model conditioned on
the chosen policy parameters. For (b), a Bayesian prior
reflecting assumptions on the class of policies is imposed on
latent variables, and the predictive posterior is obtained under
the prior. For (c), applicable to stochastic domains only, the
model is \textit{conditioned on the occurence} of the event of
interest.  The posterior is most often represented by samples,
allowing for convenient and efficient calculation of quantiles
and compatibility intervals; alternatively, variational
inference may allow performing probabilistic queries on the
posterior in closed form.

Moreover, unlike  purpose-built tools, which are often confined to
a particular type of queries, the whole arsenal of Bayesian
model checking, evaluation, and comparison~\cite[Chapters
6--7]{gcs+:03} becomes available when probabilistic programming
is used to define the model.

% \subsection{???}

% Auto-diff?

% Description of potential translation methods

% Examples of annotations

% Potential example of using program structure to support RL, as in reward machines

\section{Research Agenda}
The discussion above suggests natural research questions:
\subsubsection{Planning Algorithms}
The most important direction is continuing to develop planning algorithms that can exploit PPL-based action descriptions. This includes:
\begin{itemize}
    \item Efficient sampling algorithms.
    \item Model-based gradient descent algorithms that exploit our ability to auto-diff probabilistic programs.
    \item Techniques for guiding planners, including heuristics (such as novelty~\cite{Novelty}), helpful-actions,
    as used by  POMCP~\cite{SV10} and Despot~\cite{Despot} to perform roll-outs, and other techniques.
     \item Algorithms that recognize domains with special properties, e.g., deterministic, fully observable, allowing the use of special-purpose planners
    \item Algorithms that exploit component structure
    within a program for planning, such as
    deterministic components (as in reward machines and POMDP-Lite~\cite{POMDP-lite}), fully observable components, etc.
\end{itemize}
\subsection{Learning Algorithms}
A long line of work, going back at least to~\cite{YANG2007107} is concerned with  learning action models for planning. This becomes even more crucial when we allow more complex descriptions. This should be of interest to the PPL community, interested in learning PPLs in general, as it offers a more constrained setting with many potential examples. If fact, learning quantitative information with program structure fixed is {\em already supported} by existing
PPLs.

\subsection{Compilation}
Methods for compiling programs into existing formalisms (e.g., to RDDL) could be used to exploit the strength of current planning algorithms.
Approximate compilation methods can be used to provide
approximate solutions, and these could also be used to guide algorithms that solve the original problem description, e.g., as heuristics.

\section{Summary}
In this paper we argued for the use of PPLs as a language for specifying stochastic planning models. PPL makes it easier to express complex models, and their code can be exploited by planning algorithms. Indeed, models of various realistic systems cannot be captured compactly using existing formalism,
nor do associated methods scale to handle planning in them.
Moreover, PPL inference algorithms can be used by planning algorithms to support various useful inference tasks. This, of course, does not detract from the usefulness of existing methods with their associated planning algorithms. They remain useful as potential models, when appropriate, and as tools that can be exploited by richer models to support efficient
planning.


%\bibliographystyle{aaai23}
\section{Appendix: Code Examples}
In the following pages we provide PPL pseudo-code for the Locust Swarm and
Room Cleaning domains and verified RDDL code for the Locust Swarm domain.
\onecolumn

\input{LocustsDomain_PPL}
\bigskip
\bigskip
\input{openWorldCode}
\input{LocustsDomain_RDDL}
\twocolumn
\section{Acknowledgements}
This work was supported by the Israel Ministry of Science and Technology Grant 3-15626, ISF Grant
1651/19 
\clearpage
\bibliography{all_v2}
%%%
\end{document}