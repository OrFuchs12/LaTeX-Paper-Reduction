

\section{The Taskify Theorem}\label{sec:Taskify-construction}
We will now generalize the model for materiality into the $\sTaskify$ construction, which will essentially: (1) construct a transformed CID that contains the original CID, but has a normal form tree (by \autoref{le:20nov29.1-Existence-of-adequate-CID-split-from-nothing}), and (2) take a model on the original CID, and extend it to a model on the transformed CID by parameterizing the tree. For the second part, \autoref{def:model-construction} is almost the operation that we want. The only problem with it is that it sometimes assigns an extra boolean bit to the domain of the decision $D$. We need this extra bit in order to ensure that $D$ performs its task in case the root system 
\ryan{Not quite right, because referring to the root system makes it sound like  $X \to D$ is just in one place, and this only needs to be done once.  Maybe we should leave this line out in our next rewrite.}
\chris{but $X\to D$ IS in just one place, right? I'm not sure what the confusion is.}
\ryan{The confusion lies in the fact that you're parameterising multiple tasks.}
\chris{What multiple tasks? let's discuss, bc its not clear to me.}
has a non-directed info path. But for the purpose of usability, we would like the Taskify operation not to change the domain of any of the nodes in the original CID. This makes it easier to reason about the model using the Taskify lemma. We will fix this by doing one additional CID transformation, to make it so that this extra bit is in a different node, and porting the model to that transformed CID:~\looseness=-1




\begin{definition} [Transformation 4] \label{def:21jan30.2-fifth-transformation-to-split-root-decision}
Let $\sG^3=(\sV^3,E^3)$ be a CID \withSR with a tree  $T^3$.
Then $\splitfourth(\sG^3,T^3)=\sG^4$ 
where $\sG^4=(\sV^4,E^4)$
and the CID homomorphism $\hfourth\colon \sV^4 \to \sV^3$ are obtained from \autoref{le:21may19.2-CID-hom-from-node-copying-and-deleting}, by adding for each node $N$ a set of copies
    \[\sCopies(N) = \begin{cases} 
        \{(N,``\scopy")\} \casesif {$N=D^{\sRoot^{T^3}}$ and $\sRoot^{T^3}$ has non-directed info path}\\
        \emptyset \casesotherwise
    \end{cases}.\]
\end{definition}







\begin{definition} [Model adjustment for transformation 4] \label{def:21feb7.3-model-adjustment-after-fifth=transformation}
Let $\calM^3$ be the model from \autoref{def:model-construction} on a CID $\sG^3$ based on some $T^3$, $\calM^0$ and $\piTask^{D}$. Then we obtain a model $\calM^4$ on the CID $\sG^4=\splitfourth(\sG^3, T^3)$ as follows: If the root system has a directed info path, then $\sG^4 =\sG^3$ by definition and let $\calM^4=\calM^3$. If it has a non-directed info path, then $\calM^4$ is obtained from model $\calM^3$ by the following changes. 
\begin{itemize}
    \item Let $\dom^{\calM^4}((D,``\scopy"))=\bool$, and let $\dom^{\calM^4}(D)=\dom^{\calM^3}_\sbase(D)$.  

    \item Any chance node $N \in \Ch(D)$ is given $f^N_{\calM^4}(d,``\scopy",\pa^{\calM^4}(N)^-)=f^N_{\calM^3}((d,``\scopy"),\pa^{\calM^4}(N)^-)$, where $\pa^{\calM^4}(N)^-$ denotes the values of $\pa^{\calM^4}$ except for $d$ and $``\scopy"$, and $(d,``\scopy")$ denotes the concatenation of $d$ and $\scopy$.
    \chris{Is concatenation the right word here?}
\end{itemize}
\end{definition}




\begin{lemma} [$\calM^3$ and $\calM^4$ are equivalent] \label{le:21feb7.1-Transformation-4-produces-an-equivalent-model}
If model $\calM^4$ and homomorphism $\hfourth$ are obtained from a model $\calM^3$ on $\sG^3$ by \autoref{def:21jan30.2-fifth-transformation-to-split-root-decision}, then $\calM^3=\hfourth(\calM^4)$, i.e. it is the ported model of $\calM^4$ via $\hfourth$.
\end{lemma}


\begin{proof}
This follows directly by definition.
\end{proof}


Now we have all the ingredients needed to define the Taskify construction for a single decision. That is, the construction that assigns a task to a single decision.










\begin{definition} [Taskify Construction for a single decision] \label{def:taskify-construction-single}
The operation $\sTaskifySingle$ takes a CID $\sG$, a model $\sM$ on it, and for some decision $D$ a deterministic decision rule $\piTask^{D}$ that only depends on a single parent $X$ in the minimal d-reduction of $\sG$, and outputs a triple $\sTaskifySingle(\sG, M, \piTask^{D}) = (\GTaskify, \MTaskify, h)$ that are obtained as follows:
\begin{itemize}
    \item (Obtain a transformed CID with normal form tree) Let  $\sG^3=(\sV,\sE)$ be a CID
    with a normal form tree $T^3$ on it, and a homomorphism $\hfirsttolast$ from $\sG^3$ to $\sG$, where the root info-link $X^3 \to D^3$ of $T^3$ satisfies $h(X^3)=X$ and $h(D^3)=D$ (which exists by \autoref{le:20nov29.1-Existence-of-adequate-CID-split-from-nothing}). 
    
    \item (Parameterize this using the normal form tree) Let the model $\calM^3$ on $\sG^3$ be obtained by applying \autoref{def:model-construction} to the model $\sM$ on the nodes in $\sG$, using $\piTask^{D}$ and $T^3$.
    
    \item (Split the root decision) Define $\GTaskify=\splitfourth(\sG^3, T^3)$ with homomorphism $\hfourth$ from $\GTaskify$ to $\sG^3$ (from  \autoref{def:21jan30.2-fifth-transformation-to-split-root-decision}), and obtain $\MTaskify$ from $\calM^3$ according to \autoref{def:21feb7.3-model-adjustment-after-fifth=transformation}. Finally, let $h=\hfirsttolast\circ \hfourth$.
\end{itemize}
\end{definition}




\begin{definition} [Taskify Construction] \label{def:taskify-construction-full}
The operation $\sTaskify$ takes a CID $\sG$, a model $\sM$ on it, and for some set of decisions $\DTask\subseteq \sD$ 
a deterministic decision rule $\piTask^{D^i}$ for each $D^i \in \DTask$ that depends only on a single parent $X^i$ in the minimal
$d$-reduction of $\sG$, and outputs a triple $\sTaskify(\sG, M, \{\piTask^{D^i}\}) = (\GTaskify, \MTaskify, h)$ that are obtained as 
follows: Let $N=|\DTask|$ and let $D_1,...,D_N$ be the ordering of the decisions in $\DTask$ from latest to earliest according to the ordering of decision nodes in $\sG$.\footnote{Recall that there is such an ordering due to sufficient recall.} Then:
\begin{align*}
    (\GTaskify^0, \MTaskify^0,h^0) &= (\sG, \sM, \mathrm{id})\\
    (\GTaskify^{n+1}, \MTaskify^{n+1}, \tilde h^{n+1}) &= \sTaskifySingle(\GTaskify^n, \MTaskify^n, \piTask^{D_{n+1}})\\
    h^{n+1} &= \tilde h^{n+1}\circ h^n\\
    (\GTaskify, \MTaskify, h) &= (\GTaskify^N, \MTaskify^N, h^N)
\end{align*}
\end{definition}








Now we are able to prove the Taskify Lemma. In order to keep the lemma statement simple we first define the notion of a \textit{homomorphic extension} of a model. A homomorphic extension of a model on a graph $\sG$ is essentially a model on a super-graph of $\sG$ that agrees with the original w.r.t. the nodes in $\sG$. The taskify construction in fact produces a homomorphic extension of our original model as we will show, and transformation 4 was performed primarily to obtain that property.

\defHomomorphicExtension*

\begin{lemma}[Composition of Homomorphic extensions]\label{le:21-aug9.1-composition-of-homomorphic-extensions}Let $\sM^3$ on $\sG^3$ be a homomorphic extension of $\sM^2$ on $\sG^2$, and $\sM^2$ a homomorphic extension of $\sM^1$ on $\sG^1$. Then $\sM^3$ is a homomorphic extension of $\sM^1$. 
\end{lemma}

\begin{proof} Let $h^{2\gets 3}\colon \sG^3\to \sG^2$ and $h^{1\gets 2}\colon \sG^2\to \sG^1$ be the homomorphisms from the definition of homomorphic extension.
Firstly, since $\sG_1$ is a subgraph of $\sG_2$, and $\sG_2$ a subgraph of $\sG_3$. Hence clearly $\sG_1$ is a subgraph of $\sG_3$. Secondly, define $h^{1 \gets 3} = h^{1\gets 2} \circ h^{2\gets 3}$, which is also a homomorphism by the homomorphism composition lemma (\autoref{le:20dec7.1-composition-of-CID-splits}). Thirdly, since $\sM^1$ equals $\sM^2$ on the subgraph $\sG^1$, and $\sM^2$ equals $\sM^3$ on the subgraph $\sG^2$, and we know that $\sG^1$ is a subgraph of $\sG^2$, therefore $\sM^1$ equals $\sM^3$ on the subgraph $\sG^1$.
\end{proof}





\letaskify*

The proof will proceed as follows: We will show that the operation $\sTaskify$ produces a model $\MTaskify$ that satisfies the desired properties. Since $\sTaskify$ is built by iteratively 
assigning a task from the set of given tasks $\{\piTask^{D^i}\}$ using $\sTaskifySingle$ (in arbitrary order), we first (step 1) prove that $\sTaskifySingle$ produces a model that has the desired 
properties w.r.t. that single task. This result mostly follows from the properties we proved in the previous section (in particular that the decisions must perform their task, and that if they do, the utility nodes in the normal-form tree are constant with probability 1). However, it does not immediately follow from this 
that after iteratively applying $\sTaskifySingle$ $N$ times, all the decisions will perform their task, and that all utility nodes 
are constant: We have to show that a later application of $\sTaskifySingle$ does not adjust the model in a way so that the desired properties provided by an earlier application are no 
longer true. Therefore we must show (step 2), that after the $n+1^{\mathrm{th}}$ application of $\sTaskifySingle$, the decisions $D_1,...,D_n$ still have to perform their tasks 
$\piTask^{D_1},...,\piTask^{D_n}$, and that the utility nodes in the added normal-form trees for $X_1 \to D_1,...,X_n \to D_n$ are still constant with probability $1$. Intuitively, the reason this is true is that the $n+1^\text{th}$ application of $\sTaskifySingle$ only adds utility nodes that are constant, and doesn't change the model on existing nodes, which implies that the earlier added decisions face the same decision-problem, and hence still perform their task, and still cause the earlier-added utility nodes to be constant.


\begin{proof}
We will show that the operation $\sTaskify$ as defined in \autoref{def:taskify-construction-full} generates a triple $(\GTaskify, \MTaskify,h)=\sTaskify(\sG, \sM, \{\piTask^{D^i}\}_{D^i\in \DTask})$ that satisfies the desired properties, where $h$ is the required homomorphism for $\MTaskify$ to be a homomorphic extension of $\sM$.


We first (in step 1) show the result assuming that the decisions $\DTask$ to be provided with a task contains only a single decision $D$, so that $(\GTaskify, \MTaskify,h)= \sTaskifySingle(\sG, \sM, \piTask^{D})$. Since $\sTaskify$ is built up from repeated applications of $\sTaskifySingle$ we will use this in step 2 to show the general result by induction.



\textit{Step ($1$) : The result for a single task}. 
Assume that $\DTask$ contains only a single decision $D$, so that $(\GTaskify, \MTaskify,h)= \sTaskifySingle(\sG, \sM, \piTask^{D})$. 
Let $\Vadded= \VTaskify \setminus \sV$. We show each desired property in succession:

($\MTaskify$ is a homomorphic extension of $\sM$). Firstly, the graph $\sG$ is a subgraph of $\GTaskify$ directly by the definition of $\sTaskifySingle$ (\autoref{def:taskify-construction-single}). Secondly, by definition, $h=\hfirsttolast\circ \hfourth$, and since $\hfirsttolast$ and $\hfourth$ are homomorphic (\autoref{le:20nov29.1-Existence-of-adequate-CID-split-from-nothing}, \autoref{def:21jan30.2-fifth-transformation-to-split-root-decision}), so is $h$ (\autoref{le:20dec7.1-composition-of-CID-splits}). Thirdly, that $\MTaskify$ equals $\sM$ on the subgraph $\sG$ follows directly by definition of \autoref{def:model-construction} and \autoref{def:21jan30.2-fifth-transformation-to-split-root-decision} for all nodes except $D^i$, and if the root system of $T$ is directed then also for $D^i$. If it is non-directed, then the domain of $D^i$ has one boolean added to it in the model from \autoref{def:model-construction}, but we remove this in \autoref{def:21jan30.2-fifth-transformation-to-split-root-decision}.

\ref{le:21jan31.3a-taskify-optimal-iff-performs-task} {(\TaskifySublemmaPerformsTheirTaskName)} 
Firstly, by definition of $\sTaskifySingle$, $\MTaskify=\splitfourth(\sM^3)$, where $\sM^3$ is the standard
model obtained from a normal form tree as introduced in the beginning of \autoref{sec:model-definition}. 
We have already proven (\autoref{le:1.7-optimal-iff-truthful}) for $\sM^3$ that $D$ must perform its task under any optimal policy in the sense of \autoref{def:aug23.4-task-performance}. Hence, since $\calM^3=\hfourth(\MTaskify)$ (by \autoref{le:21feb7.1-Transformation-4-produces-an-equivalent-model}) so that $\MTaskify$ and $\sM^3$ are equivalent in the sense of \autoref{le:cidhom1-equivalence}, this implies that for any optimal policy on $\MTaskify$, that $\pi^{D^i}(a\mid\pa)=\piTask^{D^i}(x^i)$ as required.



\ref{le:21jan31.3c-taskify-added-utility-nodes-unaffected} {(\TaskifySublemmaAddedUtilityNodesName)}.
This is shown for $\calM^3$ in \autoref{le:1.7-optimal-iff-truthful}. Since $\calM^3=\hfourth(\MTaskify)$ (by \autoref{le:21feb7.1-Transformation-4-produces-an-equivalent-model}), so that for any policy $\spi$ on $\MTaskify$, the outcomes of $\MTaskify$ with $\spi$ and $\calM^3$ with ${\hfourth(\spi)}$ are equivalent in the sense of \autoref{le:cidhom1-equivalence}, therefore these models result in the same utility for any policy. Hence the same holds for $\MTaskify$.








\textit{Step ($2$) : The result for $N$ tasks}. 
Let $\Vadded^{n+1:n} = \VTaskify^{n+1} \setminus \VTaskify^n$ and  also $\Vadded^{n+1}=\VTaskify^{n+1} \setminus \sV$.
From step ($1$) it follows that for each $n$, the model $\MTaskify^{n}$ satisfies the desired properties relative to $\MTaskify^{n-1}$. That is, $\MTaskify^{n}$ is a homomorphic extension of $\MTaskify^{n-1}$ in which (a') $D_n$ must perform its task, and (b') the utility nodes in $\Vadded^{n:n-1}$ have a constant value. 
But we must show the stronger result that for each $n$, $\MTaskify^n$ is a homomorphic extension of $\sM$ in which (a) Each of $D_1, ...,D_n$ performs its task, and (b) the utility nodes in $\Vadded^n$ have a constant value. Intuitively, we must show that each application of $\sTaskifySingle$ doesn't undo the properties obtained by the previous applications.

We show these stronger properties by induction: We assume that they hold for $(\GTaskify^n, \MTaskify^n, h^n)$, and show that they hold for $(\GTaskify^{n+1}, \MTaskify^{n+1}, h^{n+1})$. Setting $n+1=N$ then finishes the proof.

($\MTaskify^{n+1}$ is a homomorphic extension of $\sM$). We know that $\MTaskify^{n+1}$ is a homomorphic extension of $\MTaskify^n$ from step (1), and that $\MTaskify^n$ is a homomorphic extension of $\sM$ from the induction assumption. Hence by \autoref{le:21-aug9.1-composition-of-homomorphic-extensions} $\MTaskify^{n+1}$ is a homomorphic extension of $\sM$. 

\ref{le:21jan31.3a-taskify-optimal-iff-performs-task} {(\TaskifySublemmaPerformsTheirTaskName)} Firstly, we know that for each utility node in in $\GTaskify^n$, its expected value in $\MTaskify^{n+1}$ equals that in $\MTaskify^n$, since by 
step ($1$) $\MTaskify^{n+1}$ is a homomorphic extension of $\MTaskify^{n}$. And for each added utility node in $\Vadded^{n+1}$, the value is constant, so long as the decision rules for $D_{n+1}$ and the decisions in $\Vadded^{n+1}$ are optimal again by step ($1$) \ref{le:21jan31.3c-taskify-added-utility-nodes-unaffected}. Hence the expected utility given each possible decision rule for $D_1,...,D_n$ is the same in $\MTaskify^{n+1}$ as in $\MTaskify^n$. Hence, since the induction assumption implies that for any optimal policy on $\MTaskify^n$, the decision rules for $D_1,...,D_n$ equal their tasks, the same holds for $\MTaskify^{n+1}$. 
Finally, that for any optimal policy on $\MTaskify^{n+1}$ the decision rule for $D_{n+1}$ is equal to its task follows directly by step ($1$) \ref{le:21jan31.3a-taskify-optimal-iff-performs-task}.



\ref{le:21jan31.3c-taskify-added-utility-nodes-unaffected} {(\TaskifySublemmaAddedUtilityNodesName)}
Take a policy $\pi$ for which each decision in $\{D_1,...,D_{n+1}\}\cup\Vadded^{n+1}$ has an optimal decision rule. Then in particular this holds for each decision in $\{D_{n+1}\}\cup \Vadded^{n+1:n}$, so that by step (1)(b), the 
utility nodes in $\Vadded^{n+1:n}$ have constant value in $\MTaskify^{n+1}$. Moreover, by step 1, $\MTaskify^{n+1}$ is a homomorphic extension of $\MTaskify^n$, so that in particular, $\GTaskify^{n}$ is a subgraph of $\GTaskify^{n+1}$ on which $\MTaskify^{n+1}$ equals $\MTaskify^n$, which implies that if we restrict $\pi$ to the subgraph $\GTaskify^n$ then this gives us a 
policy $\pi'$ for $\MTaskify^n$. Moreover, since $\pi$ had optimal decision rules for each decision in $\{D_1,...,D_{n+1}\}\cup\Vadded^{n+1}$ and hence also in $\{D_1,...,D_{n}\}\cup\Vadded^{n}$, and the utility of the nodes in $\Vadded^{n+1:n}$ are constant, this implies together with the equivalence between $\MTaskify^{n+1}$ and $\MTaskify^n$ that 
$\pi'$ is optimal on $\MTaskify^n$, which implies by the induction assumption that all utility nodes in $\Vadded^n$ are constant in $\MTaskify^n$. Since the model $\MTaskify^{n+1}$ is equal to $\MTaskify^n$ on the subset of nodes $\VTaskify^n$, this means that they are also constant in $\MTaskify^{n+1}$. 
\end{proof}




































    

