\sectionStart{PTAs} 
\par Probabilistic timed automata (PTAs) are a formalism for modeling systems whose behavior incorporates both probabilistic and real-time characteristics. ~\cite{norman2013model} ~\cite{kwiatkowska2009stochastic} A probabilistic timed automaton resembles nondeterministic finite automaton reinforced with integer-valued variables, probabilistic transitions, and a concept of time passage. In the basic form, PTA consists of the following final sets: 1. Variables - integer-valued variables. 2. Clocks - non-negative real-valued variables, which all increase with the same rate. 3. Constraints - logical TRUE value, logical operator AND, logical operator NOT, and comparison of sums of clocks with variables. 4. Locations (nodes) - a finite set of locations, with single initial location. 5. Actions (edges) - a finite set of transitions between locations. 6. Invariant condition - constraint on a location. 7. Enabling condition - constraint on an action. 8. Probabilities - a probability of transition of enabled actions. Automaton state includes current node and the assigned values to clocks and variables. The transition function between states allows two types of transitions: 1. Time transition - ab advancement of all clocks by certain time interval, while invariant of a current node is fulfilled. 2. Action transition - transition on an enabled edge which is chosen according to the probability, as part of transition the values of variables and clocks can be updated to new values. Therefore, automaton starts at the initial node, and advance through edges according to invariants and enabling conditions. 
\par We are using a slightly stronger PTA model with a few augmentations: 1. Variables are real-valued numbers. 2. Urgent nodes - a node without time transition so clocks can advance by it. 3. Variable value can be updated as an outcome of function on variables or probabilistic value according to some distribution. 4. We use multiple concurrent PTAs (they can be encoded as a single PTA by parallel composition). 5. Channels - a way to synchronize two or more PTAs to transition on edges at the same time, one can always send a signal on a channel, but the receiver must wait until signal sent.
\par We present here an example of PTA for a connection protocol with up to three retries represented in a graphical form. 
\frameImage{examplePta.eps}{1.8in}{3.42in}{Example PTA for connection protocol.} \colorsTable


  



There are two clocks: “x” and “y”. Node “connect\_try” is the initial node, with invariant: “x <= 2 and y<= 9”. At time $\big[0,1\big)$ it is impossible to transition with edges because of the guards(enabling conditions). Up until two time units, PTA can stay at “connect\_try”, but then it must transition on edge to “connect\_done” (with probability 0.9) or “connect\_retry\_delay” (with probability 0.1). If transitioned to “connect\_done” it sends a signal on “chan\_connect” channel and remains at “connect\_done” state. If transitioned to “connect\_retry\_delay”, it waits for “x” to become 3, then update “x” to 0 and transition to “connect\_try” for another connection attempt. If all three attempts to connect fail, the automaton will transition from  “connect\_try” to “connect\_failed”, send a signal on “chan\_connection\_failed” channel, and will remain in “connect\_failed” state.




\sectionEnd{PTAs}
________________


\sectionStart{A Formal Semantics for PLPs} 
\par We want to incorporate all essential characteristics and behaviors of PLPs by the means of PTA model. For each PLP type (achieve, maintain, etc.) we go over its specification and create a representative PTA template, i.e., PTA\textsubscript{PLP} that would embody PLP’s qualities such as run time distribution, a probability of success and failure, values changes of variables in a goal condition, etc. There are many similar elements in all PLPs types that we implement in a similar manner.
\subsubsection{Variables} 
\par For a given set of PLPs representing a certain system, we list all variables, parameters, constants, and resources, then we match a PTA\textsubscript{PLP} variable for each. PTA\textsubscript{PLP} variables are initialized according to the values from PLPs initializations. We also create one status variable for each PLP, that is used as an indication if PTA\textsubscript{PLP} is currently running or not.
\subsubsection{Conditions}
\par With an introduction of variables to PTA\textsubscript{PLP}, we can build upon them conditions used by PLPs. In PLPs the concept of “condition” used in two distinctive ways: 1.  The usual meaning of  “condition” as a logical expression that can be either true or false, for example, “a = b” is true if a value of “a” and value of “b” is the same value. 2. In the meaning of a statement that needs to be true and requires variables to be adjusted accordingly, i.e. value assignment, for example, “a = b” is an assignment of a value of “b” to the variable “a”. The distinction between the two meanings is easy to make depending on the role of the condition in PLP, for example, the precondition of PLP is always a logical condition that may be true or false, while goal condition of PLP is always used as adjustment of variables with assignments.
\par For conditions in the meaning of logical condition, we use PTA’s guard condition (enabling condition) of an edge. PLP condition translated to a certain PTA guard condition of an edge between two nodes in PTA\textsubscript{PLP}. The first step of PLP condition conversion is to simplify NOT operators with complex operands, by implication of De Morgan's laws, into NOT statements with simple operands. The PLP’s condition is translated inductively to PTA’s condition. Base cases: 1. PLP Variable - converted to a respective variable in PTA. 2. PLP predicate - converted to PTA variable that may be true or false. 3. PLP formula - comparison between variables and constants translated to a comparison between respective PTA variables and constants. Logical NOT added if need. Construction of more sophisticated conditions achieved with logical OR and AND. Induction step: 1. AND - logical conjunction from PLP condition transferred intact to PTA format.  2. OR - logical disjunction in PLP created in PTA by creating an edge for each operand. 
\par For conditions in the meaning of assignment, we use PTA’s update part of an edge to assign new values for variables and clocks. PLP condition translated to a certain PTA update of an edge between two nodes in PTA\textsubscript{PLP}. PLP condition in assignment format has to be much more restrictive than logical conditions. Generally, it is a list created by AND operands, with items of two types: PLP predicate and PLP formula. In the transition to PTA: 1. AND operators are ignored. 2. Predicates - converted to respective PTA variables, and assigned true value, and false if accompanied with NOT operator. 3. Formula - variables are translated to respective PTA variables, and formula translated to PTA assignment.   

\par PLP condition also supports universal quantification, FOR ALL, and existential quantification, EXISTS, quantifier. At present we do not support them.
 \subsubsection{Achieve}
\par For a given PLP achieve we can create PTA\textsubscript{PLP} achieve.
\frameImage{ptaAchieve17.eps}{2.76in}{3.32in}{A template of PTA\textsubscript{PLP} achieve. }
\par Logical conditions in PLP are converted to guard conditions in the above PTA as follows: 1. Preconditions to “preconditions”. 2. Concurrency conditions and concurrent modules constraints are gathered into $m\textsubscript{1}$ statements that connected with AND operator into “concurrent\_constraints”, for each statement $i\textsubscript{1} \in \big[ 1, m\textsubscript{1} \big]$ there is a path to “trap\_concurrent\_i1” from “main” with a guard “!concurrent\_constraint\_i1”. 3. Required resources are gathered into $m\textsubscript{2}$ statements that connected with AND operator into “resources\_constraints”, for each statement $i\textsubscript{2} \in \big[ 1, m\textsubscript{2} \big]$ there is a path to “trap\_resource\_i2” from “main” with a guard “!resource\_constraint\_i2”. 4. Repeat state of a PLP represented by boolean variable “repeat”. 
\par Assignment conditions in PLP are converted to assignments in the above PTA as follows: 1. Goal updated by statements in “goal” in the transition between “main\_done” to “end”. 2. Side effects as defined in PLP do no reveal when exactly the change happen, therefore we decided to make the change immediately before PTA is ending in a transition between  “main\_done” and “end”.
\par Constraints between concurrent modules accomplished by usage of “running” status variable for each PTA\textsubscript{PLP}. It is true while PTA emulates PLP’s running state, and any other PTA can form a condition to run alongside it or prohibit such scenario.
\par We assume there are $m\textsubscript{3}$ failure states for PLP, each one represented by $i\textsubscript{3} \in \big[ 1, m\textsubscript{3} \big]$ path leading to “failure\_i3” with probability “probability\_failure\_i3”.
\par PTA\textsubscript{PLP} starts at initial node “wait”, in which it is waiting to start by some central scheduling PTA. The transition from “wait” to “start” node occurred upon arrival of a signal on a channel “can\_start” scheduling PTA, which symbolize PLP’s scheduling. The first thing that PLP need to do is to check if the preconditions are fulfilled, which we accomplish in PTA\textsubscript{PLP} by a transition from “start” to “choose” with guard condition “precondition”. Then PTA decides what kind of PLP execution should it be, a successful or one of the failures, it’s accomplished by probabilities “probability\_success” and “probability\_failure\_i3”. If failure path is chosen, it will wait for “run\_time” time according to distribution “Df\_i3()” in “failure\_i3” node and then stay in “trap\_failure\_i3” state. If a successful PLP execution chosen, PTA transition from “choose” node to “main”.  Time can pass in the “main” node according to the run time distribution “Ds()” stored in “run\_time” variable. Despite the fact that current path represents a successful internal execution of the PLP, external constraints may still force PLP to fail, which we represent by “main” invariant condition “concurrent\_constraints $\&\&$ resources\_constraints”. In case of failure caused by a concurrent condition, concurrent module, or resource, PTA will transition to “trap\_concurrent\_i1” or “trap\_resource\_i2” respectively. Otherwise, external constraints fulfilled while in “main”, and transition to “main\_done” is possible. The transition to “end” node updates goal conditions and side effects. In case a repeat mode is enabled, PTA will transition to “repeat\_wait”, and then to “start” for another cycle of PTA\textsubscript{PLP} run. If repeat mode disabled, PTA will transition to “wait”, and let scheduler PTA know it is done by a signal on “run\_scheduler” channel.
\subsubsection{Maintain}
\par For a given PLP maintain we can create PTA\textsubscript{PLP} maintain.
\frameImage{ptaMaintain17.eps}{2.16in}{3.32in}{A template of PTA\textsubscript{PLP} maintain.}
\par PTA\textsubscript{PLP} maintain is similar to PTA\textsubscript{PLP} achieve with a few changes: 1. No repeat path because PLP maintain does not support it. 2. There is an additional node “wait\_maintain\_true” that mimics PLP maintain time needed for maintain condition to become true, maintain assignments are updated by “maintained” in a transition to “main” node. 3. Termination of PLP with positive outcome accomplished by “termination\_success” condition, that can force a transition to “main\_done”. 4. Termination of PLP with failure outcome accomplished by “termination\_failure” condition, that can force a transition to “trap\_failure\_termination”.
\par In the template above PTA\textsubscript{PLP} maintain is writing the “maintained” assignments only once before “main” node. It is also possible to enforce two additional behaviors: 1. Make sure that the assignments in “maintained” are not overwritten with other values, it can be accomplished by converting “maintained” assignments to a logical condition in invariant of “main” node, and creation of a failure state in case it has changed while in “main”. 2. We can enforce “maintained” assignments by converting “main” node into two nodes, we can force a transition every interval of time, and every such transition would write “maintained” assignments.
\subsubsection{Observe}
\par For a given PLP observe we can create PTA\textsubscript{PLP} observe.
\frameImage{ptaObserve17.eps}{2.76in}{3.32in}{A template of PTA\textsubscript{PLP} observe.}
\par PTA\textsubscript{PLP} observe is similar to PTA\textsubscript{PLP} achieve with a change in transition between “main\_doin” and “end”, which is now assigning the possible values to the observed variable, according to the domain of the observed variable.
\subsubsection{Detect}
\par For a given PLP detect we can create PTA\textsubscript{PLP} detect.
\frameImage{ptaDetect17.eps}{2.3in}{3.32in}{A template of PTA\textsubscript{PLP} detect.}
\par PTA\textsubscript{PLP} detect is similar to previous PTAs\textsubscript{PLP} with adjustment: 1. There is only one internal failure path. 2. There is no time distribution for success path, only a termination with a positive outcome.
\subsubsection{Failures handling}
\par We should notice that currently any failure state leading to a trap state, which is a design that wants to investigate paths with zero internal PLPs failures. To address systems with failure recovery mechanism, we may change PTA\textsubscript{PLP} design in such way that traps states may still lead to a completion of the PTA\textsubscript{PLP}, although without obtaining goals and side effects.
\sectionEnd{A Formal Semantics for PLPs}


________________


\sectionStart{Control Graphs} 
\par Control graph is a control structure to describe an algorithm controlling execution of robotic modules specified by PLPs, enhanced with probabilities, conditional branching, and parallel execution. We define a control graph as a directed graph, that always start with single execution path from a root node, it advances according to conditions and probabilities on edges. Each node type comes in two variations: 1. Starts only when \textbf{all} of its immediate predecessors are ended. 2. Starts whenever \textbf{any} of its immediate predecessors is ended. There are four types of control nodes: 1. PTA\textsubscript{PLP} launcher node - launches sequence of PTA\textsubscript{PLP} execution one at a time. 2. Probabilistic node - chooses a single edge to proceed with according to the probability of the edge. 3. Conditional node - chooses a single edge to proceed with, according to the condition of the edge that must be satisfied. If more than one condition is true, the path would be chosen nondeterministically between all the satisfied conditions. 4. Concurrent node - executes all the outdoing edges concurrently. Nodes in the control graph can update values of variables; variables that are used both by PTAs\textsubscript{PLP} and other nodes in a control graph. 
\par We formalize control graph by defining PTA for each node (PTA\textsubscript{Node}). PTAs\textsubscript{Node} exist alongside PTAs\textsubscript{PLP} and can influence each other with shared variables and channels.
\par In the following PTA\textsubscript{Node} templates, PTAs\textsubscript{Node} starts at “init\_node”. To proceed, either all (“*” is logical AND) immediate predecessors, or any (“*” is logical OR) immediate predecessor, need to finish. 
\subsubsection{PTA\textsubscript{PLP} launcher node}
\frameImage{nodeSequential.eps}{3.3in}{1.62in}{A template for PTA\textsubscript{Node} launcher of PTAs\textsubscript{PLP}.}
When the condition to run is satisfied, PTA\textsubscript{Node} goes over the sequence of PTAs\textsubscript{PLP} it should execute, and signals each PTA\textsubscript{PLP} in a time to run with “pta\_start[i]” ($\forall i \in \big[1..m\big]$) channel, then waits for PTA\textsubscript{PLP} to complete running on “pta\_done[i]” channel. When all PTAs\textsubscript{PLP} finished running, PTA\textsubscript{Node} updates “successor\_can\_run” for successor PTA\textsubscript{Node} to run. Eventually, signals to successor PTA\textsubscript{Node} on “try\_to\_run\_successor” channel to start running if possible.
\subsubsection{Probabilistic node}
\frameImage{nodeProbability.eps}{3.3in}{2.9in}{A template for probabilistic PTA\textsubscript{Node}.}
When the condition to run is satisfied, PTA\textsubscript{Node} waits in a wait state, for a time interval determined by control graph. Then the PTA\textsubscript{Node} chooses a single path to follow, out of the possible $k$ paths, according to the specified probability of each path. Then the PTA\textsubscript{Node} updates “successor\_can\_run[i]” ($i \in \big[1..k\big]$) for successor node to run. Eventually, signals to the successor on “try\_to\_run\_successor[i]” channel to check if it can run.
\subsubsection{Conditional node}
\frameImage{nodeCondition.eps}{3.3in}{2.9in}{A template for conditional PTA\textsubscript{Node}.}
When the condition to run is satisfied, PTA\textsubscript{Node} waits in a wait state, for a time interval determined by control graph. Then the PTA chooses a single path to follow, out of the possible $k$ paths, by conditions on edges. In the PTA\textsubscript{Node} template below the conditions are: “condition[1] == true, …, condition[k] == true”. Then the PTA\textsubscript{Node} updates “successor\_can\_run[i]” ($i \in \big[1..k\big]$) for chosen successor node. Eventually, signal to successor on “try\_to\_run\_successor[i]” channel to check if it can run.
\subsubsection{Concurrent node}
\frameImage{nodeConcurrent.eps}{3.5in}{1.52in}{A template of concurrent node.}
When the condition to run is satisfied, PTA\textsubscript{Node} waits in a wait state, for a time interval determined by control graph. Then the PTA\textsubscript{Node} updates “successor\_can\_run[i]” ($\forall i \in \big[1..k\big]$) for all successors nodes. Then the PTA\textsubscript{Node} signals to each successor on “try\_to\_run\_successor[i]” channel to check if it can run. We should notice that other nodes receive signal on “try\_to\_run\_successor[i]” channel in a sequential manner. If their run condition fulfilled and they can run, they will only pass the synchronization edge, rest of their executions can be scheduled later, regardless of the synchronization edge. For example, if node “id\textsubscript{1}” passed synchronization first, and then node “id\textsubscript{2}” , the next transition can be scheduled to be by “id\textsubscript{2}” or “id\textsubscript{1}” , and each execution can produce different scheduling combinations.
% \subsubsection{Loop extension}
% Control graph extension with circles allows to express easily more robust algorithms. To support loops in control graph we need to make a few changes in the PTAs\textsubscript{Node} definitions: 1. We remove the usage of channels between PTAs\textsubscript{Node} to signal when to start. 2. In the node “init\_node” we add invariant: for AND nodes - invariant is a logical disjunction on predecessors’ pass statuses; for OR nodes - invariant is a logical conjunction on predecessors’ negation of a pass statuses. 3. The transition from  “init\_node” to  “wait”, 
\sectionEnd{Control Graphs}
%\section%Start%{Limitations} 
%\section%End%{Limitations}


\sectionStart{Control Graph Verifier} 
\par To verify control graph with PLPs, we produce a set of PTAs representing this system, which allows ask certain queries about the system. Specifically, we use UPPAAL model checking tool for this task. UPPAAL is a software package developed jointly by Uppsala and Aalborg Universities, for modeling, validation, and verification of real-time systems modeled as networks of timed automata, extended with data types  ~\cite{behrmann2006uppaal}. 
\par UPPAAL allows us to ask temporal propositions on a state (location and variables values) about the whole system as follows (p and q propositions): 1. Does exist a path for p to be eventually true. 2. Does for all paths, p is true all the time. 3. Does exist a path, that p true all the time. 4. Does for all the paths, p eventually true. 5.  Does for all the paths, if p is true, q will be eventually true. 6. Calculate the probability of q to be eventually true. 7. Calculate the probability of q to be always true.
\subsubsection{Implementation with UPPAAL}
\par There are a few restrictions in UPPAAL that require adaptations of PTAs we defined.
\par Variables in UPPAAL restricted to integer values. To minimize loss of precision we multiply all the variables and durations by adjustable precision factor and truncates the fraction part.  
\par UPPAAL supports uniform and exponential distributions, but not general run time distributions. To implement other distributions used by PLPs we create an approximation with uniform distribution by discretization of the original distribution.
\par Invariant in UPPAAL restricted to a conjunction/disjunction of simple comparisons between variable/clock and constant values. Due to heavy reliance on invariants in the PTAs\textsubscript{PLP} we had to make a few changes ~\cite{kovalchu2018} to PTAs\textsubscript{PLP} to work around this problem. We need to be able to make immediate transitions when a value of a variable in critical condition changes, this can be achieved by sending a signal on a channel for each changed variable. Therefore such critical condition, that contains a few variables, should have an edge with a channel corresponding to every variable, and guard condition as original condition. But it forces us to make sure that any write to a variable, that may be part of a critical condition, have to send also a signal on a channel corresponding to that variable. This issue was addressed ~\cite{kovalchu2018} by a creation of a mechanism to read/write shared variables by any PTA and with channels to signal about the change to other PTAs, without additional time delays in a process.
\sectionEnd{Control Graph Verifier}