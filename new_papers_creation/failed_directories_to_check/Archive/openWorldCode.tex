\DeclareCaptionFormat{}{\hrule}
\begin{lstlisting}[floatplacement=h,numbersymbol=$:$,language=json,caption={The Room Cleaning domain in pseudo PPL code.},label={lst:openWorld_PPL},basicstyle=\tiny]
toys_properties enum {size, inplace, price, grasping_difficulty}
toys=[{0.1,true,0.3,0.1},{0.8,false,0.2,0.1},{6.8,false,1.5,0.2}] \\The 'toys' list is the only state variable.

//'order_toy_action' is the index of the toy that should be ordered. 's' is the state we want to sample (the next state and reward) from. 
function sample_next_state(order_toy_action,s) 
    reward = 0
    toy = s.toys[order_toy_action] //Get the toy the robot should handle.
    if not toy[inplace] //If toy not in place
        if sample_bernoulli(toy[grasping_difficulty]) //Sample if the toy falls and breaks based on its grasping difficulty.
            reward = -toy[price] //Give a negative reward based on the toy price.
            s.toys.remove(toy) //Remove the broken toy from the toys list.
        else
            toy[inplace]=true //If the robot could grasp the toy, it is said to be in place.
 
    foreach toy in s.toys //Give a positive (negative) reward for each toy (not) in place by its size.
        if toy[inplace]
            reward = reward + toy[size]
        else
            reward = reward - toy[size]
            
    number_of_toys_to_add = sample_discrete(0.4,0.3,0.3) //Sample the number of new toys found (zero:0.4, one:0.3, or two:0.3). 
    for 1 to number_of_toys_to_add //Add toys as the amount found.
        new_toy = {absolute_value(sample_normal(1,1), sample_bernoulli(0.2),
                                    sample_uniform(0,4), sample_uniform(0,0.4)} //Sample the new toy properties.
        s.toys.append(new_toy) //Add the new toy to the toys list.
    return reward,s //Return the reward and the sampled next state.
\end{lstlisting} 